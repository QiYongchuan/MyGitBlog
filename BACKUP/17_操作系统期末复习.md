# [操作系统期末复习](https://github.com/QiYongchuan/MyGitBlog/issues/17)

[操作系论课上.pdf](https://github.com/QiYongchuan/MyGitBlog/files/11729893/default.pdf)
* 选择题 5题，10分
* 简答题 4道    20分  【第7章文件系统  12/16题 5分  第三章 死锁 5分   
* 计算题 4道    40分   【第六章磁盘调度算法10分（优缺点需要注意一下简答）、第四章、第五章页面置换算法30分】
* 应用题  2道   30分  【可能的点：1.进程同步问题（爸妈放水果15分）  2.银行家算法（15分）】


![image](https://github.com/QiYongchuan/MyGitBlog/assets/105039020/9fac1951-b146-4e8e-a767-b031918f4074)

### 简答题可能的点
第一章
1.视从交互性、及时性和可靠性比较实时系统和分时系统


交互性：实时信息处理系统具有交互性，但人与系统的交互仅限于访问系统中某些专用服务程序，不像分时系统那样能向终端用户提供数据和资源共享等服务。

 及时性：实时信息查询系统对实时性的要求与分时系统类似，都是依人所能接收的等待时间来确定，而实时控制系统的及时性，是依控制对象所要求的开始截止时间或完成截止时间来确定的，一般为秒级到毫秒级。

  可靠性：分时系统也要求系统可靠，但相比之下，实时系统则要求系统具有高度的可靠性。因为任何差错都可能带来巨大的经济损失，甚至是灾难性后果，所以在实时系统中，往往都采取了多级容错措施保障系统的安全性及数据的安全性。
[来源](https://www.cnblogs.com/livelihao/p/5235403.html) 以及课本P12

2.OS有哪些特征，最基本的特征是？

操作系统的特征有：并发、共享、虚拟、异步，最基本的特征是并发（进程在同一时间间隔内交替执行）和共享（多个计算机进程共享计算机资源）


第二章 
![image](https://github.com/QiYongchuan/MyGitBlog/assets/105039020/48564a56-793d-44e4-96b0-e0233b52348a)
(1 )调度性。线程在 OS 中作为调度和分派的基本单位,进程只作为资源拥有的基本单位。 (2 )并
发性。进程可以并发执⾏,⼀个进程的多个线程也可并发执⾏。 (3 )拥有资源。进程始终是拥有资
源的基本单位,线程只拥有运⾏时必不可少的资源,本身基本不拥有系统资源,但可以访问⾪属进程
的资源。 (4 )系统开销。操作系统在创建、撤消和切换进程时付出的开销显著⼤于线程。

第三章
1.死锁
**1.何为死锁，死锁产生的必要原因？必要条件（简答题）**
多个进程因循环等待它方占有的非剥夺性资源竞争而无限期地僵持下去的局面。
原因：非剥夺性资源的竞争和进程的不恰当推进顺序。
必要条件：互斥条件 不剥夺条件 请求和保持条件 循环破坏条件

在计算机系统中，死锁指的是多个进程或线程因为竞争有限的资源而相互等待，导致系统无法继续执行下去。类比中的死锁可以是多个工人互相等待对方释放资源，最终导致整个工厂停止生产。

第四章 存储器管理
1.引入动态重定位？如何实现？
所谓地址重定位，就是当⼀个程序装⼊到与其地址空间不⼀致的存
储空间⽽进⾏的地址变换过程，即将地址空间给出的逻辑地址映射到内存的物理
地址上。地址重定位有静态重定位和动态重定位两种⽅式。
采⽤内存分区管理时，在硬件上设置⼀个“重定位寄存器”可以实现程序运⾏时的
动态重定位。这种情况下地址重定位是在程序执⾏期间由地址变换机构动态实现
的，主要的计算依据是：物理地址=逻辑地址+重定位寄存器的内容。

2.分页系统地址变换
![image](https://github.com/QiYongchuan/MyGitBlog/assets/105039020/f80a6042-a61f-4294-b54f-fc01eb8e8937)

第六章  
1.各磁盘调度算法的优缺点
2. 中断处理程序通常需要完成哪些工作
设备中断处理程序通常需完成如下⼯作:(1) 唤醒被阻塞的驱动程序进程;(2) 
保护被中断进程的CPU环境;(3) 分析中断原因、转⼊相应的设备中断处理程
序;(4) 进⾏中断处理;(5) 恢复被中断进程。

第七章
1.文件目录
2.索引

### 计算题


第三章  进程 
1.银行家算法（10分）
2.进程同步：  爸妈放水果以及 消费者生产者   以及哲学家吃饭（10分）

第四章 存储

#### 1.连续分配存储管理
动态分区分配（可变）
![image](https://github.com/QiYongchuan/MyGitBlog/assets/105039020/268c499a-c10c-43d9-8e23-e26b29202f9a)

| 算法 |  算法实现  | 算法优点 | 算法缺点 |
| ---- | ---- | ---- | ---- |
| 首次适应算法（first fit） | 地址，由地址由上到下的顺序分配 | 优先利用低址地区空间分区，为高址地区保留了大片空闲区。| 低址地区不断的划分，产生大量的碎片，每次查找时从低址地区开始查找增加了查找时开销。|
| 最佳适应算法（best fit) | 容量最合适的那一个（从小到大排序） | 把能满足要求、又是最小的空闲分区分配给作业，避免了大材小用 | 宏观上看产生了大量难以利用的碎片
| 最坏适应算法（worst fit）| 容量，选择最大的那个（从大到小排序）|算法查找效率高，产生碎片的可能性小 | 储存器缺乏大的空闲分区 | 

![image](https://github.com/QiYongchuan/MyGitBlog/assets/105039020/200f1ba9-6ae5-42b1-a5c8-20bbc82de57c)
![image](https://github.com/QiYongchuan/MyGitBlog/assets/105039020/977166d0-0424-444e-9cdc-78bf05f65954)

<detail> 答案   </detail>

需要注意的点：1.每个动作对应 已分配分区 与 空闲分区   2. 已分配分区（作业，始址，大小）  空闲分区（始址，大小）  3.各算法的区别（首次适应是地址，最佳是剩余分区容量）


#### 2.非连续分配存储管理
基本分页存储管理
![image](https://github.com/QiYongchuan/MyGitBlog/assets/105039020/21d734a5-de19-4d67-a72c-32d881ca2b53)

（2）在请求分页存储管理中，系统是通过页表进行地址转换。
      先将逻辑地址分解成页号P和页内地址W两部分，然后查页表，可得页号P对应的物理块号为B，从而变换出对应的物理地址为：
      物理地址=块号×页面大小+页内地址



第五章：虚拟内存 只考这一道 （10分）
1.请求分页存储管理（页面置换算法）

![image](https://github.com/QiYongchuan/MyGitBlog/assets/105039020/f3448016-0b96-4cd4-b40d-279ba9d2818a)




---

## 第二章  进程的描述与控制  进程与线程
![image](https://github.com/QiYongchuan/MyGitBlog/assets/105039020/05f28bef-1185-4341-91a4-72d8a284c0c8)

> 
> 进程是操作系统中的一个基本概念，它是指正在运行的程序的实例。每个进程都有自己的地址空间、内存、文件句柄、环境变量等资源。进程是操作系统中资源分配的基本单位，不同的进程之间相互独立，互不干扰。
> 
> 线程是进程中的一个执行单元，它是进程中的一个实体，负责执行进程中的代码。一个进程可以包含多个线程，这些线程共享进程的地址空间和其他资源。线程是操作系统中调度的基本单位，不同的线程之间可以共享进程的资源，但是也需要进行同步和互斥。
> 
> 并发是指多个任务在同一时间段内执行，它是一种处理多任务的方式。在计算机系统中，多个进程或线程可以同时执行，从而实现并发处理。并发可以提高系统的吞吐量和响应速度，但是也需要考虑同步和互斥的问题。

**类比**

* 进程类比为一个工厂，每个工厂都有自己的资源和生产线，可以独立地生产产品。
* 线程则可以类比为工厂中的工人，他们负责具体的生产工作，共享工厂的资源和生产线。
* 程序可以理解为工厂的生产计划，它描述了工厂需要生产的产品种类、数量、生产流程等信息。在操作系统中，程序是指一组指令的集合，它们按照一定的顺序组成，可以被计算机执行。程序需要被加载到内存中才能运行，而进程则是程序在内存中的实例。因此，可以将程序看作是工厂的生产计划，而进程则是根据生产计划创建出来的实际工厂。
*  操作系统可以类比为工厂的管理者，负责协调和管理各个工厂的资源和生产线，以确保整个生产系统的稳定和高效运行。操作系统需要管理进程和线程的创建、调度和销毁，同时还需要提供各种系统调用和服务，以支持应用程序的运行。

* 并发则可以类比为多个工厂同时生产产品，从而提高整个生产系统的效率。
* 共享在工厂中，共享可以指多个工人共同使用同一台机器或同一种原材料，以提高生产效率。在操作系统中，共享可以指多个线程或进程共享同一块内存或同一种资源，以提高系统的利用率和效率。共享需要考虑同步和互斥的问题，以避免资源竞争和数据不一致的情况。在工厂中，可以通过制定工作流程和规定使用机器的时间来实现共享；在操作系统中，可以通过使用锁、信号量等同步机制来实现共享。


### 线程与进程的比较：试从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较。
（1）调度性：进程为资源拥有的基本单位，线程在OS中作为调度和分派的基本单位。
（2）并发性：进程可以并发执行，一个进程内多个线程也可并发执行。
（3）拥有资源：进程始终是拥有资源的基本单位，线程只有在运行时拥有必不可少的资源，本身基本不拥有系统资源，只能访问隶属进程的资源。
（4）系统开销。系统在创建、撤销和切换进程时付出的开销显著大于线程。

_理解：1.工厂拥有资源的单位，而工人只是干活的单位；2.工厂和工人都可以同时处理多项任务； 3.工厂始终拥有资源，工人只有在工厂工作时才拥有一些必要的资源，但这些资源都不是工人的，工人可以使用，但无权拥有。 4.开销：创建、撤销、转换一家工厂所需要的花费成本必然比更换工人要高。_

###  线程与程序的比较：试从动态性、并发性和独立性上比较进程和程序

（1）动态性：进程最基本的特性，表现为由创建而产生，由调度而执行，因得不到资源而暂停执行，以及由撤销而消亡，因而进程有一定的生命周期；而程序只是一组有序指令的集合，是静态实体。
（2）并发性：并发性是进程重要的特征，同时也是OS的重要特征，引入进程的目的正是为了使其程序能和其他进程的程序并发执行，而程序不能并发执行。
（3）独立性：是指进程实体是一个能够独立运行的基本单位，也是系统中独立获得资源和独立调度的基本单位。 而对于未建立任何进程的程序，都不能作为一个独立的单位参与运行。

_理解：程序可以理解为工厂的生产计划，它描述了工厂需要生产的产品种类、数量、生产流程等信息。在操作系统中，程序是指一组指令的集合，它们按照一定的顺序组成，可以被计算机执行。程序需要被加载到内存中才能运行，而进程则是程序在内存中的实例。因此，可以将程序看作是工厂的生产计划，而进程则是根据生产计划创建出来的实际工厂_


**  总结：**
1.进程的定义：**  进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的独立单位。 **
2.进程的特征：
动态性、并行性、独立性、异步性
![image](https://github.com/QiYongchuan/MyGitBlog/assets/105039020/316bc28e-2aa4-49b3-b3ee-99ef84bf3fb1)


### 进程的基本状态和转换

![image](https://github.com/QiYongchuan/MyGitBlog/assets/105039020/6a9ae058-6f16-41f7-9ebf-61bf4e18cfb3)

在工厂中，进程的基本状态可以类比为工厂的生产状态，包括就绪状态、运行状态、阻塞状态和终止状态。就绪状态表示工厂已经准备好了生产，等待工人的分配和调度；运行状态表示工人正在生产产品；阻塞状态表示工人暂时无法继续生产，需要等待某些条件满足；终止状态表示工厂已经完成了生产任务，可以关闭或销毁。

### 试说明进程在三个状态之间转换的基本原因
- 处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便会由就绪状态转变为执行状态
- 当前进程因发生某件事无法执行，如访问已被占用的临界资源，就会使进程由执行状态转化为阻塞状态
- 当前进程因时间片用完而被暂停执行，该进程便由执行状态转变为就绪状态。


---

## 第三章 处理机调度与死锁

![image](https://github.com/QiYongchuan/MyGitBlog/assets/105039020/baafabdc-76bf-4791-9f4e-cb1267b595e7)

### 1.何为死锁，死锁产生的必要原因？必要条件（简答题）

多个进程因循环等待它方占有的非剥夺性资源竞争而无限期地僵持下去的局面。
原因：非剥夺性资源的竞争和进程的不恰当推进顺序。
必要条件：互斥条件 不剥夺条件 请求和保持条件 循环破坏条件

在计算机系统中，死锁指的是多个进程或线程因为竞争有限的资源而相互等待，导致系统无法继续执行下去。类比中的死锁可以是多个工人互相等待对方释放资源，最终导致整个工厂停止生产。

### 2.如何避免死锁=>银行家算法

银行家算法是一种资源分配和避免死锁的算法。在工厂的类比中，可以将银行家看作是工厂的资源管理员。当工人们需要申请资源时，银行家会进行分配，但是会根据当前的资源情况来判断是否分配资源会导致死锁。银行家算法确保资源的安全分配，避免了死锁的发生。
![image](https://github.com/QiYongchuan/MyGitBlog/assets/105039020/6f5d3c3f-0cb7-4a17-a7f0-fe1d4519c6b5)

step1：Max -Allocation = Need  先求出need来，用最大-分配的
![image](https://github.com/QiYongchuan/MyGitBlog/assets/105039020/710ab2fd-d4c4-4ca0-9701-c6eb8aa9a300)
step2: Determine The Safe Sequence 确认安全序列
![image](https://github.com/QiYongchuan/MyGitBlog/assets/105039020/7ab7f264-d5a5-474f-af0b-454b17d6c023)
这一步是比较Avaiable与Need，是否是大于等于Need
![image](https://github.com/QiYongchuan/MyGitBlog/assets/105039020/2385391c-da3b-462b-86e6-88199e40b285)

如果Available >= Need  则为安全序列，设置为T，然后更新New Available = Available + Allocation  ,用更新后的Available 去继续比较下一个的Need
![image](https://github.com/QiYongchuan/MyGitBlog/assets/105039020/0d515d4f-a1f7-4fbb-8612-e1262c78f3db)

如果Available <= Need,则不是安全序列，就为F，此时不更新Available，继续比较下一个  
![image](https://github.com/QiYongchuan/MyGitBlog/assets/105039020/970df959-f14b-4d40-8b0e-e976242f6333)

依次完成上述的计算比较：
![image](https://github.com/QiYongchuan/MyGitBlog/assets/105039020/e786f849-b725-4f22-bf8a-10d44e84dd98)
别忘了最后比较完，如果T，依然要计算新的Available。
![image](https://github.com/QiYongchuan/MyGitBlog/assets/105039020/13af6877-887f-4405-b649-67b7cb4d8c78)

将最后得到的Available，回头再比较第一次为F(为满足分配的）序列，如果此时成立，就修改为序列以及T
![image](https://github.com/QiYongchuan/MyGitBlog/assets/105039020/f64a628b-682c-4459-b44c-2d607c108154)

最后，得出安全序列：（按Need的从小到大顺序）

![image](https://github.com/QiYongchuan/MyGitBlog/assets/105039020/c22552c9-eb36-45e1-babf-b9b2a6d102be)


#### 死锁银行家算法，考试版本，计算

![image](https://github.com/QiYongchuan/MyGitBlog/assets/105039020/7fea88f0-ffd9-4008-8a00-3c49b726c2dc)
![image](https://github.com/QiYongchuan/MyGitBlog/assets/105039020/1acc8fa8-733e-47cd-a1e0-64579343a5e8)


| 进程 | work  |  Allocation  | Need  |  Work + Allocation |  Finish|
| ---  |  --- |  ---| ---|---| ---|

补充说明：
1. work 就是available，可利用的资源（理解成目前可以工作的资源， Need 是需要的资源，用来比较work是否满足其需求；  Allocation 是已占用的资源，每一次进程结束后，这部分资源就释放到，增加到work去。）

2.关于Request请求； 本质上可以理解成是一次资源的重新分配，前提是需要满足
* R <= Available
* R <= Need

其次，资源的重新分配：
available = available - request
Need = need - request

allocation = allocation + request

这里可以看出是相当于把available部分的资源，分到了（某一进程）的allocation部分了；

完成上述步骤后，开始新一轮的银行家算法的步骤即可；




---

### 第四章、进程同步
#### 经典进程同步问题（PV原语）
##### 生产者、消费者
##### 哲学家干饭
##### 爸妈装水果
### 第五章、存储器管理
#### 连续分配存储管理
##### 动态分区分配（可变）
#### 非连续分配存储管理
##### 分页存储管理
### 第六章、虚拟存储器
#### 请求分页存储管理
##### 页面置换算法

---

### 第七章 文件管理
* 本章可能涉及一道简答题 10分

1.文件目录和目录文件各起什么作用？目前广泛采用的目录结构形式是哪种？它有什么优点？

在文件系统中，文件目录记录文件的管理信息，又称为文件控制块，或者文件说明信息，文件系统把同一卷上的若干文件的文件目录组成一个独立的文件，这个文件全部由文件目录组成，称为目录文件。

文件目录用于对单个文件的控制，它记录文件的名字、文件长度、文件存放在外存上的物理地址，以及文件属性和文件建立时间、日期等信息。

目录文件是全部文件目录组成的文件，用于整个文件系统的管理。

文件的目录结构一般有三种形式：一级目录、二级目录、多级树形目录。

一级目录简单方便，但不允许文件重名。

二级目录由主目录和用户文件两个目录组成，可以解决文件的重名和别名问题。

多级树形目录是二级目录的扩充。目前广泛采用的目录结构形式是树形目录结构。它的主要优点是：检索效率高，允许文件重名，确切反映了信息的层次结构并可以利用层次结构实现文件共享和保护。

2.试说明对索引文件和索引顺序文件的检索方法
* 索引文件的检索，首先根据用户（程序）提供的关键字，利用折半查找法检索索引表，找到相关项；再根据给出的指向记录指针值，访问对应记录。
* 索引顺序文件的检索，首先利用用户（程序）提供的关键字及查找方法，检索索引表，找到该记录在记录组中的第一条记录表项，得到第一个记录在主文件中的位路；再利用顺序查找法查找主文件，找到所要求的记录。



---

![c8040000b2921ba98f9989b5d5b3cb8](https://github.com/QiYongchuan/MyGitBlog/assets/105039020/54c792c9-443f-45ac-9179-816eb1bcbb11)
